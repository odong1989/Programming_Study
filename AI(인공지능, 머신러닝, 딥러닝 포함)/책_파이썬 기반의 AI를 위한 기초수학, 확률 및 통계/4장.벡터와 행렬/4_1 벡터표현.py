# -*- coding: utf-8 -*-
"""4_1 벡터표현.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17CJFuLR7Ah9PAIz-KxdD_9AUhlc7WkWd
"""

#필요한 패키지(4_0 4장에서 사용되는 파이썬 패키지안내.)

import numpy as np
import scipy

from scipy import linalg as la
import matplotlib.pyplot as plt

#버전 확인
print(np.__version__)
print(scipy.__version__)

#--------------------------------------------------------------------------

#4.1.0 벡터의 생성 및 벡터의 원소

# 벡터의 생성
v = np.array([0.61, 0.93, 0.24, 0.27])
print(v)

#벡터의 원소
v = np.array([0.61, 0.93, 0.24, 0.27])
print(v[0])

#4.1.1. 벡터의 크기(size, deimension, length)
#벡터의 크기(size, deimension, length)나, 벡터의 차원은 벡터의 개수를 의미함.

v = np.array([0.61, 0.93, 0.24, 0.27])
v.shape

#4.1.2. 부분 벡터(sub vector)
#벡터의 부분벡터는 쌍점(:, colon)을 통해 표현한다.

v =np.array([0.61, 0.93, 0.24, 0.27])
v_sub = v[0:2]
v_sub

#4.1.3 특별한 벡터(0벡터, 단위벡터, 1벡터)

#4.1.3.1. 0벡터 
# 0벡터 : 모든 원소가 0인 벡터.
size =3 
zeros = np.zeros(shape=(size,) )
zeros

#----------------------------------------

#4.1.3.2. 단위벡터 
# 단위벡터 : 하나의 원소만 1이고, 나머지는 모두 0인 벡터.
#            단위벡터는 특별히 'e표기법'을 활용한다. 

size=3
e = np.zeros(shape=(3,))

#단위벡터의 위치
i=1

#단위벡터 생성
e[i]=1
e

#------------------------------------------

#4.1.3.3. 1벡터
#1벡터 : 모든 원소의 값이 1인 벡터.

size =3
one = np.ones(shape=(size, ))
one

#4.1.4벡터의 기하학적 의미

#별도의 코드는 없음.
#책 53페이지에서 자세히 설명을 읽도록 하자.

#4.1.5. 벡터 연산

#4.1.5.1. 벡터 덧셈연산
#벡터의 덧셈연산자는 덧셈과 이외로 (1)교환법칙, (2)결합법칙이 성립한다

#4.1.5.1.1. 벡터의 덧셈연산

a=np.array([1,3])
b=np.array([3,1])
a+b

#출력결과
#array([4, 4])

#------------------------------------------

#4.1.5.1.2. 벡터의 교환법칙
a+b == b+a 
#출력결과
#array([ True,  True])

#------------------------------------------

#4.1.5.1.3. 벡터의 결합법칙
d=np.array([1,2])
(a+b)+d == a+(b+d)

#출력결과
#array([ True,  True])

#책(54~55) 참조
#위의 법칙들이 기하학적으로 갖는 의미는 
#"b의 끝에서 다시 a만큼 위치이동(평행이동)하는 것이다"

#4.1.5. 벡터 연산
#4.1.5.2. 벡터 뺄셈

#벡터의 뺄셈
a = np.array([1,3])
b = np.array([3,1])
b-a

#출력결과
#array([ 2, -2])


#책56 참조
#"덧셈은 a를 시작점으로 하여 b를 더하여 만드는 것이고,"
#"뺄셈은 q벡터를 시작점으로 하여 p-q만큼 더하여 p를 만드는 것이다."

#4.1.5. 벡터 연산
#4.1.5.3. 벡터곱셈
#4.1.5.3.1. 스칼라-벡터 곱
alpha = 1/2
a = np.array([2,3])
alpha*a

#출력결과
#array([1. , 1.5])

#------------------------------------------


#책57 참고
#"스칼라 곱은 '같은 비율로 축소/확대만 할 뿐'이다."
#스칼라 곱은 교환법칙과 분배법칙이 성립한다.


#4.1.5.3.2.스칼라곱-교환법칙
alpha *a == a*alpha

#출력결과
#array([ True,  True])

#------------------------------------------

#4.1.5.3.3. 스칼라곱-분배법칙
beta=0.7
(alpha + beta) * a == alpha * a + beta *a

#출력결과
#array([ True,  True])

#4.1.6 내적(내적계산)
#내적계산
a = np.array([-1, 2, 3])
b = np.array([1,-2, 4])

#원소별 곱 벡터
a*b

#연산결과
#array([-1, -4, 12])

#------------------------------------------

#원소별 곱 벡터 합
np.sum(a*b)
#출력결과
#7

#------------------------------------------

#함수 이용
np.inner(a,b)
#출력결과
#7

np.dot(a,b)
#출력결과
#7

#------------------------------------------
#7/12시작!
#내적의 성질
a = np.array([-1,2,3])
b = np.array([1,-2,4])

#교환법칙
np.dot(a,b) == np.dot(b,a)
#출력결과 
#True

#결합법칙
alpha = 0.5
np.dot(alpha *a,b) == alpha * np.dot(a,b)
#출력결과 
#True

#분배법칙
c = np.array([1,2,3])
np.dot(a+b,c ) == np.dot(a,c) + np.dot(b,c)
#출력결과 
#True

#------------------------------------------
#내적의 활용

a = np.array([1,2,3])
size = len(a)
ones = np.ones(shape=(size,))

#합의 표현
np.dot(ones, a)
#출력결과
#6.0

#평균의 표편
np.dot(ones,a)/ len(a)
#출력결과
#2.0

#제곱합의 표현
np.dot(a,a)
#출력결과
#14

#4.1.7. 벡터 노름(유클리디안 노름을 말하는 것임)


#------------------------------------------
#4.1.7.1. 필요한 패키지
from scipy import linalg as la

#벡터 노름의 계산
a = np.array([2,3])
la.norm(a)
#출력결과
#3.605551275463989

#62페이지의 예제
# :  a=0.5에 대하여 노름의 성질의 성립함을 확인해보자

#벡터 노름의 성질
a = np.array([-1,2,3])
b = np.array([1,-2,4])

#스칼라 곱
beta = 0.5
la.norm(beta*a) == np.abs(beta) * la.norm(a)
#출력결과
#True

#삼각형의 한 변의 길이는 다른 두변의 길이의 합보다 작다.
la.norm(a+b) <= la.norm(a) * la.norm(b)
#출력결과
#True

#길이는 0보다 크거나 작다.
la.norm(a) >= 0
#출력결과
#True

#4.1.8 내적과 노름
#코드는 없음. 설명만 있음. 63페이지 읽어보기 바람.

#4.1.9벡터 선형종속

#4.1.9.1. 기저
#코드 없음.설명은 64~65 페이지 참고

#4.1.9.2. 직교정규 벡터
#65페이지 예제

#직교정규 벡터 확인
a1 = np.array([0,0,1]).reshape(-1,1)
a2 = 1/np.sqrt(2) * np.array([1,1,0]).reshape(-1,1)
a3 = 1/np.sqrt(2) * np.array([1,-1,0]).reshape(-1,1)

#노름=1, 열들의 곱 = 0
A = np.concatenate((a1, a2, a3), axis=1)
np.round(A.T @ A, 3)

#출력결과
#array([[ 1.,  0.,  0.],
#       [ 0.,  1., -0.],
#       [ 0., -0.,  1.]])

