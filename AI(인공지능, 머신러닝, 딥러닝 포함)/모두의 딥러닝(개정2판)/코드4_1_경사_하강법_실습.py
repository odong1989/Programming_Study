# -*- coding: utf-8 -*-
"""코드4-1 경사 하강법 실습.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_qVZLKkygGee9644m0luAJ4gIX_43kEO
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#공부 시간 x와 성적 y의 리스트를 만든다
data = [ [2,81], [4,93], [6,91], [8,97] ]
x = [i[0] for i in data]
y = [i[1] for i in data]

#그래프로 나타내기
plt.figure(figsize=(8,5))
plt.scatter(x,y)
plt.show()

#리스트로 되어 있는 x와 y값을 넘파이 배열로 바꾸기
#(인덱스를 주어 하나씩 불러와 계산이 가능하게끔 하기 위함)

x_data = np.array(x)
y_data = np.array(y)
print("x_data:",x_data)
print("y_data:",y_data)

#기울기 a와 절편 b의 값 초기화
a=0
b=0

#학습률 정하기
#Ir = 0.05
lr = 0.03

#몇 번 반복될지 설정
epohcs = 2001

#경사 하강법 시작
for i in range(epohcs): #ephocs수만큼 반복된다
    y_pred = a * x_data + b #y를 구하는 식을 세운다.
    error = y_data - y_pred #오차를 구하는 식
    
    #오차 함수를 a로 미분한 값.
    a_diff = -( 2/len(x_data) ) * sum(x_data * (error) )    
    #print("a_diff:",a_diff)

    #오차 함수를 b로 미분한 값.
    b_diff = - ( 2/len(x_data) ) * sum(error)
    #print("b_diff:", b_diff)

    a = a - Ir * a_diff #학습률을 곱헤 기존의 a값을 업데이트
    b = b - Ir * b_diff #학습률을 곱해 기존의 b값을 업데이트

    if i % 100 == 0: #100번 반복될때마다 현재의 a,b값들을 출력한다
        #print("epoch=%.f, 기울기:%.4f, 절편:%.4f" %(i,a,b))
        print("epoch=%.f, 기울기=%.04f, 절편=%.04f" % (i, a, b))

#앞서 구한 기울기와 절편을 이용해 그래프를 다시 그리기
y_pred = a * x_data + b
plt.scatter(x,y)
plt.plot([ min(x_data), max(x_data)], [min(y_pred),max(y_pred) ])
plt.show()

#------아래는 저자분의 제공코드. 잘 작동함. 내꺼랑의 차이는 무얼까? -ㅅ-)>



#리스트로 되어 있는 x와 y값을 넘파이 배열로 바꾸어 줍니다.(인덱스를 주어 하나씩 불러와 계산이 가능해 지도록 하기 위함입니다.)
x_data = np.array(x)
y_data = np.array(y)

# 기울기 a와 절편 b의 값을 초기화 합니다.
a = 0
b = 0

#학습률을 정합니다.
lr = 0.03 

#몇 번 반복될지를 설정합니다.
epochs = 2001 

#경사 하강법을 시작합니다.
for i in range(epochs): # epoch 수 만큼 반복
    y_hat = a * x_data + b  #y를 구하는 식을 세웁니다
    error = y_data - y_hat  #오차를 구하는 식입니다.
    a_diff = -(2/len(x_data)) * sum(x_data * (error)) # 오차함수를 a로 미분한 값입니다. 
    b_diff = -(2/len(x_data)) * sum(error)  # 오차함수를 b로 미분한 값입니다. 
    a = a - lr * a_diff  # 학습률을 곱해 기존의 a값을 업데이트합니다.
    b = b - lr * b_diff  # 학습률을 곱해 기존의 b값을 업데이트합니다.
    if i % 100 == 0:    # 100번 반복될 때마다 현재의 a값, b값을 출력합니다.
        print("epoch=%.f, 기울기=%.04f, 절편=%.04f" % (i, a, b))

# 앞서 구한 기울기와 절편을 이용해 그래프를 그려 봅니다.
y_pred = a * x_data + b
plt.scatter(x, y)
plt.plot([min(x_data), max(x_data)], [min(y_pred), max(y_pred)])
plt.show()